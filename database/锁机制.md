# 锁机制 #

## 前言 ##

我们在谈数据库锁机制时，经常被悲观锁和乐观锁这两个概念困扰，容易混为一谈。首先我们要明确的是悲观锁和乐观锁是并发控制的方法，或者称为思想、理论更为确切，与数据库提供的锁机制不是一回事，数据库锁机制是基于悲观锁理论设计而来的，而乐观锁是需要我们自己实现。接下来我们就先来捋一捋悲观锁和乐观锁。

## 乐观锁 ##

乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务就要重新处理或者回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。乐观锁不是数据库自带的，是需要我们自己去实现。

简而言之，乐观锁是指在更新数据库的数据时，乐观的认为这次的更新不会导致冲突，因此不进行任何其他的特殊处理（也就是不加锁），而是在数据真正更新时，再去判断是否有冲突。

乐观锁并不会使用数据库提供的锁机制，而通常实现乐观锁的方式就是记录数据版本。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。

数据库表设计一个版本(version)字段，在对表中的数据进行每次更新时，对记录的版本号都加1。更新数据前，先查询出数据记录，获取出version字段,如果要对数据记录进行更新,则先判断此时version的值是否与查询出来时的version的值相等，如果相等，则说明这段期间内，没有其他事物对其进行过修改，则可以执行更新，然后将version字段的值加1；如果不相等，则说明这段期间内已经有其他事物对其进行修改，则不进行更新。

**优点与不足**

乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

## 悲观锁 ##

悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）也是一种并发控制的方法。悲观锁恰恰与乐观锁相反，它假设多用户并发的事物在处理是会彼此互相影响，会修改相同的数据，因此需要加锁来阻止本事物以外的其他事物对数据的修改。如果一个事务执行的操作都某行数据应用了锁，那么只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观锁是由数据库的锁机制来实现。

**优点与不足**

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。

#-----------------------华丽的分割线线-------------------------#

数据库锁机制是基于悲观锁理论设计而来的，按类别设计出共享锁、排他锁，按粒度设计出表锁、行锁、页面锁，为实现表锁和行锁共存设计出意向共享锁、意向排他锁。

**开销、加锁速度、死锁、粒度、并发性能比较**：

**表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

**行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

**页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

## 表锁 ##

MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。表锁模式的兼容性如下所示。

![](https://github.com/longtian2/cc3/blob/master/images/myisam-lock.png)

可见，对表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对表的写操作，则会阻塞其他用户对同一表的读和写操作；表的读操作与写操作之间，以及写操作之间是串行的！当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

命令：

lock table xxx write --加写锁

lock table xxx read  --加读锁

unlock tables        --释放锁

## 行锁 ##

InnoDB存储引擎实现了以下两种类型的行锁。

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

![](https://github.com/longtian2/cc3/blob/master/images/innodb-lock.png)

若将上锁的对象看成一颗树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。举例来说，在对记录 r 加 X 锁时，发现已经有事物对表 1 加了 S 锁，那么当前事物想对记录 r 所在表 1 加 IX 锁，由于不兼容，所以当前事物需要等待持有表锁的事物操作完成。

InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。

命令：

select * from xxx for update

select * from xxx lock in share model

参考文献：
   《Mysql技术内幕 Innodb存储引擎（第二版）》 姜承尧
   http://blog.csdn.net/xifeijian/article/details/20313977
   http://www.hollischuang.com/archives/934

联系方式：

https://github.com/longtian2

**如有用请不吝打赏**

![](https://github.com/longtian2/cc3/blob/master/images/wechat_pay.png)