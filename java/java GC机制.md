# Java GC机制 #

## 垃圾认定 ##

在java 虚拟机运行时数据内存分布结构一文中，我们提到程序计数器、java 栈、本地方法栈三个区域是线程私有的，会随着线程而生，随着线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 java 堆和方法区则是共享区域，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行时期才能知道会创建哪些对象，这部分内存的分配和使用都是动态的，垃圾收集器关注的就是这部分内存。

判断对象是否存活有两种算法：

**引用计数算法**

给对象中添加一个引用计数器，每当有一个地方引用它是，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象就是不再被使用的对象。

此算法实现简单，判断效率高，但是它很难解决对象之间的相互循环引用的问题。

**根搜索算法**

通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（或者说从 GC Roots 到这个对象不可达）时，则说明此对象不再被使用。

GC Roots对象从哪里来：

1、java 虚拟机栈（栈帧中的本地变量表）中的引用的对象

2、方法区中的类静态属性引用的对象

3、方法区中的常量引用的对象

4、本地方法栈中 JNI (即一般说 Native 方法) 的引用的对象

-------------------------------------------------------------------------------------------
## 垃圾回收 ##

当我们知道怎么判断对象是否存活后，不再使用的对象（垃圾对象）即可以被回收了。

**垃圾怎么回收？**

垃圾回收算法确切的说只有标记-清除算法、复制算法、标记-压缩3种，而另外1种分代收集算法个人认为是提高垃圾回收效率的方法论。

**标记-清除算法**

“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

它的主要缺点有两个：
一个是效率问题，标记和清除过程的效率都不高；
一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-mark-sweep.png)

**复制算法**

“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。新生代垃圾回收正式采用的该算法。

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-copy.png)

**标记-整理算法**

复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-mark-compact.png)

**分代收集算法**

GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。

“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

如上所述，分代收集算法是将 java 堆内存分而治之的一种方法论，根据对象的存活周期划分成新生代（Eden区、Survivor 0 和 Survivor 1 三个区）和老年代，再根据各个区域的特点选择适合该区域的回收算法。

-------------------------------------------------------------------------------------------
## 垃圾收集器 ##

java 虚拟机给我们提供了哪些收集器勒？

![](https://github.com/longtian2/cc3/blob/master/images/java-gc.png)

[上图摘自官网](https://blogs.oracle.com/jonthecollector/our-collectors)

图中如果两个收集器之间存在连线，就说明他们是可以搭配使用的。可以看到 java 虚拟机给我们提供了7中收集器。

**Serial 收集器**

Serial 收集器是最基本、历史最久远的收集器。顾名思义，这个收集器是一个单线程收集器，但是这里指的“单线程”并不仅仅是它只会使用一个CPU或者一条收集线程去完成垃圾回收工作，更重要的是他在垃圾回收时，必须暂停其他所有的工作线程（Sun 将这件事情称之为 “Stop The World”），直到垃圾回收结束。使用“复制”算法回收垃圾对象。

**Serial Old 收集器**

Serial Old 收集器是Serial 收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法回收垃圾对象。

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-serial.png)

----------------------------------------------------------------------------------------------------

**ParNew 收集器**

ParNew 收集器其实就是 Serial 收集器的多线程版本。使用多线程和“复制”算法回收垃圾对象。

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-parnew.png)

----------------------------------------------------------------------------------------------------

再讲接下来的收集器之前，我们需要先了解并行和并发的含义：

**并行（Parallel）**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

**并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行在另外一个CPU上。

**Parallel Scavenge 收集器**

Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例。

**Parallel Old 收集器**

Parallel Old 收集器是Parallel Scavenge 收集器的老年代版。使用多线程和“标记-整理”算法。

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-parallel.png)

----------------------------------------------------------------------------------------------------

**CMS 收集器**

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-cms.png)

CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：

**初始标记**（CMS initial mark）

**并发标记**（CMS concurrent mark）

**重新标记**（CMS remark）

**并发清除**（CMS concurrent sweep）

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。

优点: 并发收集、低停顿

缺点: 

1.CMS收集器对CPU资源非常敏感。在并发（并发标记、并发清除）阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。收集器线程所占用的CPU数量为：（CPU+3）/4=0.25+3/（4*CPU）。因此这时垃圾收集器始终不会占用少于25%的CPU，因此当进行并发阶段时，虽然用户线程可以跑，但是很缓慢，特别是双核CPU的时候，已经占用了5/8的CPU，吞吐量会很低。为了解决这种情况，产生了“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）。就是采用抢占方式来模拟多任务机制，就是在并发（并发标记、并发清除）阶段，让GC线程、用户线程交替执行，尽量减少GC线程独占CPU，这样垃圾收集过程更长，但是对用户程序影响小一些。实际上i-CMS效果很一般，目前已经被声明为“deprecated”。
　　
2.CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full  GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以降低内存回收次数提高性能。JDK1.6中，CMS收集器的启动阈值已经提升到92%。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。
　　
3.最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full  GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full  GC之后增加一个内存碎片的合并整理过程，但是内存整理过程是无法并发的，因此解决了空间碎片问题，却使停顿时间变长。还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full  GC之后，跟着来一次碎片整理过程（默认值是0，表示每次进入Full GC时都进行碎片整理）。

----------------------------------------------------------------------------------------------------

**G1收集器**

G1(Garbage First)收集器是JDK1.7提供的一个新的面向服务端应用的垃圾收集器，其目标就是替换掉JDK1.5发布的CMS收集器。其优点有：

1.并发与并行：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或CPU核心）来缩短停顿（Stop The World）时间。

2.分代收集：G1不需要与其他收集器配合就能独立管理整个GC堆，但他能够采用不同方式去处理新建对象和已经存活了一段时间、熬过多次GC的老年代对象以获取更好收集效果。

3.空间整合：从整体来看是基于“标记-整理”算法实现，从局部（两个Region之间）来看是基于“复制”算法实现的，但是都意味着G1运行期间不会产生内存碎片空间，更健康，遇到大对象时，不会因为没有连续空间而进行下一次GC，甚至一次Full GC。

4.可预测的停顿：降低停顿是G1和CMS共同关注点，但G1除了追求低停顿，还能建立可预测的停顿模型，可以明确地指定在一个长度为M的时间片内，消耗在垃圾收集的时间不超过N毫秒

5.跨代特性：之前的收集器进行收集的范围都是整个新生代或老年代，而G1扩展到整个Java堆(包括新生代，老年代)。

**那么是怎么实现的呢？**

1.如何实现新生代和老年代全范围收集：其实它的Java堆布局就不同于其余收集器，它将整个Java堆划分为多个大小相等的独立区域（Region），仍然保留新生代和老年代的概念，可是不是物理隔离的，都是一部分Region（不需要连续）的集合。

2.如何建立可预测的停顿时间模型：是因为有了独立区域Region的存在，就避免在Java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小（回收可以获得的空间大小和回收所需要的时间的经验值），后台维护一个优先队列，根据每次允许的收集时间，优先回收价值最大的Region（Garbage-First理念）。因此使用Region划分内存空间以及有优先级的区域回收方式，保证了有限时间获得尽可能高的收集效率。

3.如何保证垃圾回收真的在Region区域进行而不会扩散到全局：由于Region并不是孤立的，一个Region的对象可以被整个Java堆的任意其余Region的对象所引用，在做可达性判定确定对象是否存活时，仍然会关联到Java堆的任意对象，G1中这种情况特别明显。而以前在别的分代收集里面，新生代规模要比老年代小许多，新生代收集也频繁得多，也会涉及到扫描新生代时也会扫描老年代的情况，相反亦然。解决：G1收集器Region之间的对象引用以及新生代和老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描。G1中每个Region都有一个与之对应的Remembered Set,虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中(分代的例子中就检查是否老年代对象引用了新生代的对象)，如果是则通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中，当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可避免全堆扫描。

忽略Remembered Set的维护，G1的运行步骤可简单描述为：

①.初始标记(Initial Marking)

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-g1-mark.png)

②.并发标记(Concurrenr Marking)

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-g1-mark-2.png)

③.最终标记(Final Marking)

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-g1-mark-3.png)

④.筛选回收(Live Data Counting And Evacution)

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-g1-clean.png)

![](https://github.com/longtian2/cc3/blob/master/images/java-gc-g1-clean-2.png)

1.初始标记：初始标记仅仅标记GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新的对象。这阶段需要停顿线程，不可并行执行，但是时间很短。

2.并发标记：此阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，此阶段时间较长可与用户程序并发执行。

3.最终标记：此阶段是为了修正在并发标记期间因为用户线程继续运行而导致标记产生变动的那一份标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这段时间需要停顿线程，但是可并行执行。

4.筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来制定回收计划。

如果现有的垃圾收集器没有出现任何问题，没有任何理由去选择G1，如果应用追求低停顿，G1可选择，如果追求吞吐量，和Parallel Scavenge/Parallel Old组合相比G1并没有特别的优势。

![](https://github.com/longtian2/cc3/blob/master/images/java-jvm-params.png)


参考文献：

   《深入理解java虚拟机》 周志明

  https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect

   https://www.cnblogs.com/jing99/p/6072059.html
   
   https://blog.csdn.net/renfufei/article/details/41897113

联系方式：

https://github.com/longtian2

**如有用请不吝打赏**

![](https://github.com/longtian2/cc3/blob/master/images/wechat_pay.png)
