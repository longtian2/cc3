# Java 类加载机制 #


## 前言 ##

![](https://github.com/longtian2/cc3/blob/master/images/java-javac.png)

**什么是类的加载**

首先我们应该清楚，java程序之所以能够一次编译到处运行的前题是各平台安装了对应的 java 虚拟机，把耦合机器操作系统的工作交给 java 虚拟机来完成。换而言之，Java 程序（.class文件）并不是本地的可执行程序，java 程序是需要运行在 java 虚拟机之上。当运行 Java 程序时，首先运行JVM（Java虚拟机），然后再把 .class 文件加载到JVM中运行，负责加载 .class 文件的这部分就叫做类加载器（Class Loader）。

类加载指的就是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类加载的最终产物是位于堆区中的 Class 对象， Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。

类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误

## 类的生命周期 ##

![](https://github.com/longtian2/cc3/blob/master/images/java-object-init.png)

类的生命周期是从被加载到 java 虚拟机内存中开始，到从虚拟机内存中卸载为止。整个生命周期包括 7 个阶段：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段，其中验证、准备、解析统称为连接。

其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。


## 加载 ##

在加载阶段，虚拟机需要完成以下三件事情：

1、通过一个类的全限定名来获取其定义此类的二进制字节流。

2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

3、在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。


**加载.class文件的来源：**

1、从本地系统中直接加载

2、通过网络下载.class文件

3、从zip，jar，war等归档文件中加载.class文件

4、从数据库中提取.class文件

5、从其他文件（如jsp）动态编译为.class文件

6、从运行时计算生成，如动态代理


相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，通过这个对象便可以访问该对象在方法区中的数据了。加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的连接动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

## 连接 ##

**验证**：确保被加载的类的正确性

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

	   1、是否以魔数 0xCAFEBABE开头
	   2、主、次版本号是否在当前虚拟机的处理范围之内
	   3、常量池中的常量是否有不被支持的类型
	   4、指向常量的各种索引值是否有指向不存在的常量或者不符合类型的常量
	   5、constant_utf8_info 型的常量中是否有不符合 UTF-8 编码的数据
	   6、class文件中各个部分及文件本身是否有被删除或者附加的其他信息
	   ……

实际上第一阶段的验证点远远不止这些，上面这些只是从 HotSpot 虚拟机源码中摘抄的一部分，该验证阶段的主要目的是保证输入的字节流能够正确的被虚拟机解析并保存在方法区之中，格式符合描述一个 Java 类型信息的要求。
这个阶段的验证是基于字节流进行的，经过这个阶段的验证之后，字节流才会进入内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构进行验证。

元数据验证：第二阶段验证是对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求。主要目的是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。

	   1、这个类是否有父类（除java.lang.Object之外，所有类都应该有父类）
	   2、这个类的父类是否是被final修饰的类
	   3、如果这个不是抽象类，是否实现了父类或者接口中未实现的所有方法
	   4、类总的字段、方法是否与父类产生矛盾（例如覆盖父类的final字段，或者出现不符合规则的方法重载）
	   ……

字节码验证：第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法提进行校验分析。

	  1、保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如，不会出现以下情况：在操作栈中放置了一个int类型的数据，在使用时却按long类型来加载入本地变量表中
	  2、保证挑转指令不会跳转到方法体以为的字节指令上
	  3、保证方法体重的类型转换是有效的，例如，可以把一个子类对象赋值给父类数据类型，但是吧父类对象赋值给子类数据类型，或者把对象赋值给其他毫无继承关系的一个数据类型，这是不合法的

符号引用验证：最后一个阶段的校验是发生在虚拟机将符合引用转化成直接引用的时候，这个转化的动作是在连接阶段的解析阶段中发生。符合一起验证可以看做是对类自身以外（常量池中的各种符合引用）的信息进行是否匹配的校验。

	  1、符合引用中通过字符串描述的全限定名是否能够找到对应的类
	  2、在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
	  3、符号引用中的类、字段和方法的访问性（private、protected、public、default）是否可被当前类访问
	  ……

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。


**准备**：为类的 静态变量分配内存，并将其初始化为默认值

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

**1、这时候进行内存分配的仅包括类变量（static 修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。**

**2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。**

假设一个类变量的定义为： public static int value=3；

那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 putstatic指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

这里还需要注意如下几点：

对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。

对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。

对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。

如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

**3、如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。**

假设上面的类变量value被定义为： public static final int value=3；

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。

**解析**：把类中的符号引用转换为直接引用

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

 1、符号引用：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
 2、直接引用：直接引用可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局是相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池的constant_class_info、constant_fieldref_info、constant_methodref_info、constant_interfaceMethodref_info 四种常量类型。


## 初始化 ##

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义的类加载器参与之外，其余动作都由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 java 程序代码（或者说是字节码）。

在准备阶段，变量已经赋值过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序代码制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。

1、clinit() 方法是由编译器自动收集类中的所有类变量（static 修饰）的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的先后顺序所决定。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。

2、clinit() 方法与类的构造函数（或者说实例构造器init() 方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的clinit() 方法执行之前，父类的clinit() 方法已经执行完毕。因此在虚拟机中第一个被执行的clinit() 方法的类肯定是java.lang.Object。

3、由于父类的clinit() 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

4、clinit() 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit() 方法。

5、接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成clinit() 方法。但接口与类不同的是，执行接口的clinit() 方法不需要先执行父接口的clinit() 方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化是也一样不会执行接口的clinit() 方法。

6、虚拟机会保证一个类的clinit() 方法在多线程环境中被正确地加锁和同步，如果多线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit() 方法，其他线程都会阻塞等待，直到活动线程执行clinit() 方法完毕。如果一个类的clinit() 方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。


在Java中对类变量进行初始值设定有两种方式：

**①声明类变量是指定初始值**

**②使用静态代码块为类变量指定初始值**

## JVM初始化步骤 ##

1、假如这个类还没有被加载和连接，则程序先加载并连接该类

2、假如该类的直接父类还没有被初始化，则先初始化其直接父类

3、假如类中有初始化语句，则系统依次执行这些初始化语句

**类初始化时机**：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

1、创建类的实例，也就是new的方式

2、访问某个类或接口的静态变量，或者对该静态变量赋值

3、调用类的静态方法

4、反射（如 Class.forName(“com.shengsiyuan.Test”)）

5、初始化某个类的子类，则其父类也会被初始化

6、Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类


**结束生命周期**

在如下几种情况下，Java虚拟机将结束生命周期

1、执行了 System.exit()方法

2、程序正常执行结束

3、程序在执行过程中遇到了异常或错误而异常终止

4、由于操作系统出现错误而导致Java虚拟机进程终止


参考文献：

   《深入理解java虚拟机》 周志明

  https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect


联系方式：

https://github.com/longtian2

**如有用请不吝打赏**

![](https://github.com/longtian2/cc3/blob/master/images/wechat_pay.png)