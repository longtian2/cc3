# 树形结构及算法 #

## 前言 ##

树的高度：指树的最大结点层

树的度：指树中结点拥有的子树数目

树的阶：指树中结点拥有的最大子树数目

## 二叉树形结构 ##

**二叉树**：指树中每个结点最多有两个子树。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。

**满二叉树**：指高度为h，并且由2^h-1个结点组成的二叉树，称为满二叉树。换而言之，指树的根结点到叶子结点的高度都一样，且叶子结点的父结点和父结点的兄弟结点的度都为2。

**完全二叉树**：指高度为h，第1到h-1层是满二叉树，并且第h层叶子结点都是从左至右依次排布。也就是说，叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。

**二叉树的性质**

性质1：二叉树第i层上的结点数目最多为2^i-1(i>=1)

性质2：高度为h的二叉树至多有2^h-1个结点（h>=1）

性质3：包含n个结点的二叉树的高度至少为(log2 n)+1

性质4：在任意一棵二叉树中，若叶子结点的个数为n0，度为2的结点数为n2，则n0=n2+1

## 二叉树算法 ##

上述内容都只是阐述了树形结构，并没有涉及到树形结构的算法，如果以树形结构存储数据，那么怎样查找（搜索）到树中指定的数据（结点）？针对查找的过程定义了多种算法，接下来我们逐步来了解算法的演变过程。

## 二叉查找（搜索）树 ##

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-search.png)

理想的二叉查找树

二叉查找（Binary Search Tree）树又被称为二叉搜索树。假设非叶子结点X，结点X包含关键字Key，结点X的Key值计为 Key[x]。如果Y是X的左子树中的一个结点，则Key[y]<=Key[x]；如果Y是X的右子树的一个结点，则Key[y]>=Key[x]。简而言之，左子树的关键字要小于等于其父结点的关键字，右子树的关键字要大于等于其父节点的关键字。

二叉查找树的性质：

（1）若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值。

（2）任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值。

（3）任意结点的左、右子树也分别为二叉查找树。

（4）没有键值相等的结点。

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-search2.png)

不理想的二叉查找树

正式因为存在不理想的二叉查找树，增加了查找数据的成本，怎样才能提高查找的效率？于是出现了“平衡”树的概念，比如平衡二叉查找树、红黑树等。


## 平衡二叉树（AVL树） ##

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-search.png)

平衡二叉（Balanced Binary Search Tree）树又称为AVL（Adelson-Velskii and Landis）树。它是一个二叉查找树，并要求**每个结点的左右子树的高度之差的绝对值最大为1**。

旋转

在每一次插入或删除结点之后，树的平衡性都可能被破坏，这时可以通过一个简单的操作来矫正平衡–-旋转。旋转的目的就是减少高度，通过降低整棵树的高度来平衡。

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-avl-return.png)

## 红黑树(Red-Black Tree ) ##

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-rbtree.png)

红黑树是另一种算法实现的“平衡”二叉查找树。

**定义**：

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

变色

变色是为了满足定义3/4/5。但是光改变结点的颜色是不够的，还需要配合上文中提到的旋转，才能满足红黑树的定义。由于涉及到很多Case，就不一一举例，感兴趣的可以查看TreeMap的源码。


## 总结 ##

既然已经存在了平衡二叉查找树，为什么要引进红黑树？

红黑树相较于平衡二叉查找树来说是一种“不完整平衡”的树，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。

红黑树的查询性能略微逊色于AVL树，因为红黑树可能会比avl树会最多一层，也就是说红黑树的查询性能可能会比的avl树多一次比较，但是，红黑树在插入和删除上完爆avl树。avl树每次插入、删除会进行大量的平衡度计算，AVL树需要维护从被删结点到根结点路径上所有结点的平衡性；而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，最坏的情况是任何不平衡都会在三次旋转之内解决，相较于avl树为了维持平衡的开销要小得多。

------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 多叉树形结构 #

## B树（B-Tree） ##

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-btree.png)

先简单对上图说明一下：

图中的小红方块表示对应关键字所代表的文件的存储位置，实际上可以看做是一个地址，比如根节点中17旁边的小红块表示的就是关键字17所对应的文件在硬盘中的存储地址。

P是指针，不用多说了，需要注意的是：指针，关键字，以及关键字所代表的文件地址这三样东西合起来构成了B树的一个节点，这个节点存储在一个磁盘块上。


**B树是用来解决什么问题的？**

从上文中，我们知道二叉查找树、红黑树是为了解决树形结构查找效率低而产生的。B树也是如此，它最初启发于二叉查找树，二叉查找树的特点是每个非叶结点都只有两个孩子结点。然而，当数据量非常大时，将导致二叉查找树的高度很高，搜索算法自根节点向下搜索时，需要访问的结点也就变的相当多。如果这些结点存储在外存储器中，每访问一个结点，相当于就是进行了一次I/O操作，随着树高度的增加，I/O操作比内存计算要费时得多，而频繁的I/O操作会严重降低查询的效率。因此，为了减少I/O操作的次数，那么就只有降低树的高度。按照这个思路，就需要将原来的二叉查找树改为多叉，且每个结点存储更多的信息。

B树又称平衡多路查找树。指非叶子结点有多个分支（大于2），或者说是存在多个子结点（大于2）的平衡查找树。

**定义**：用阶m来定义B树。

1、树中每个结点最多包含m个孩子（m>=2）；

2、除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；

3、若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；

4、所有叶子结点都在同一层，也就是说树到每个叶子结点的高度一样；

5、每个非叶子结点中包含有n个关键字信息： (P0，K1，P1，K2，......，Kn，Pn)。其中：
   a)   Ki(i=1...n)为关键字，且关键字按升序排序，即K(i-1)< Ki。 
   b)   Pi(i=1...n)为指向子结点的指针，子结点的所存储的所有关键字均小于Ki，但都大于K(i-1)。 
   c)   当前结点所包含的关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。

平衡二叉查找树、红黑树是通过变色、旋转方式来满足各自的定义，B树是通过分离、合并的方式来满足自身定义。

分裂：
 
在插入操作时，如果被插入结点A包含的关键字已达到最大值，此时，需要将结点A分裂，分裂后,将中间关键字([ceil(m / 2)])分配给父结点，小于中间关键字一侧的关键字分配给左子树结点，大于中间关键字一侧的关键字分配给右子树结点。

合并：

在删除操作时，如果被删除结点A包含的关键字已到达最小值，此时，需要向父结点申请合并。合并的情况存在很大Case，感兴趣的同学可以下来研究一下。


## B+树 ##

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-b+tree.png)

B+树是B树的一种变形，它把所有的数据信息都存储在叶子结点上，非叶子结点只存放关键字和指向子节点的指针。

**定义**：用阶m来定义。

1、除根结点外的内部结点，每个结点最多有m个关键字，最少有[ceil(m / 2)]个关键字。其中每个关键字对应一个子树（也就是最多有m棵子树，最少有⌈m2⌉棵子树）；

2、根节点要么没有子树，要么至少有2棵子树；

3、所有的叶子结点包含了全部的关键字以及这些关键字指向文件的指针，并且：

 a) 所有叶子结点中的关键字按升序排列

 b) 相邻的叶子结点顺序链接（相当于是构成了一个顺序链表）

 c) 所有叶子结点在同一层

4、所有的非叶子结点可以看成是索引部分，非叶子结点中仅含其子结点（根结点）中的最大（或最小）关键字


**为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？**

**1) B+树的磁盘读写代价更低**

B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

**2) B+-树的查询效率更加稳定**

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

**3）B+树更有利于对数据库的扫描**

数据库索引采用B+树的主要原因是：B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。


## B*树 ##

![](https://github.com/longtian2/cc3/blob/master/images/java-tree-b++tree.png)

B*树是B+树的变种，相对于B+树他们的不同之处如下：

（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为[ceil(2/3*m)]，即块的最低使用率为2/3（代替B+树的1/2）。

（2）B+树结点满时就会分裂，而B*树结点满时会检查兄弟结点是否满（因为每个结点都有指向兄弟的指针），如果兄弟结点未满则向兄弟结点转移关键字，如果兄弟结点已满，则从当前结点和兄弟结点各拿出1/3的数据创建一个新的结点出来。

特点：

在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟结点的指针，可以向兄弟结点转移关键字的特性使得B*树分配新结点的概率比B+树要低，空间使用率更高。

参考文献：

   https://blog.csdn.net/v_JULY_v/article/details/6530142/

   http://www.sohu.com/a/201923614_466939

   https://blog.csdn.net/guoziqing506/article/details/64122287

   https://blog.csdn.net/qq_25806863/article/details/74755131

联系方式：

https://github.com/longtian2

**如有用请不吝打赏**

![](https://github.com/longtian2/cc3/blob/master/images/wechat_pay.png)